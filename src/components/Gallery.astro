---
import { v2 as cloudinary } from "cloudinary";
import { Picture } from "@astrojs/image/components";
import { Icon } from "astro-icon";

export interface Props {
  folder: string;
}

export interface CloudinaryResource {
  secure_url: string;
  resource_type: string;
  width: number;
  height: number;
  duration: number;
  aspect_ratio: number;
  context: { alt: string };
}

cloudinary.config({
  cloud_name: import.meta.env.PUBLIC_CLOUDINARY_CLOUD_NAME,
  api_key: import.meta.env.PUBLIC_CLOUDINARY_API_KEY,
  api_secret: import.meta.env.SECRET_CLOUDINARY_API_KEY,
  secure: true,
});

const search = await cloudinary.search
  .expression(`folder:${Astro.props.folder}`)
  .with_field("context")
  .sort_by("filename", "asc")
  .max_results(500)
  .execute();

const resources = search.resources as CloudinaryResource[];
---

<div class="flex flex-wrap m-0.5">

  {resources.map((CloudinaryResource, index) => (
    <div
      data-position={`${index == 0 ? "first" : index + 1 == resources.length ? "last" : "middle"}`}
      onclick="setFullscreen(this, 'fadeIn')"
      ontouchend="if (!isScrolling) setFullscreen(this, 'fadeIn')"
      class="relative m-0.5 cursor-zoom-in"
      style={`flex-grow: ${CloudinaryResource.width * 300 / CloudinaryResource.height}; flex-basis: ${CloudinaryResource.width * 300 / CloudinaryResource.height}px;`}
    >

      <!-- placeholder for proper grid sizing -->
      <div class="block" style={`padding-bottom: ${CloudinaryResource.height / CloudinaryResource.width * 100}%`}></div>

      {CloudinaryResource.resource_type == "image" ? (
        // loading icon only shown in fullscreen mode
        <div role="status" class="absolute top-1/2 left-1/2 hidden -translate-x-1/2 -translate-y-1/2">
          <Icon name="loading" class="inline w-20 h-20 mr-2 text-gray-200 animate-spin dark:text-gray-600 fill-blue-600" />
          <span class="sr-only">loading image...</span>
        </div>

        <Picture
          src={CloudinaryResource.secure_url}
          aspectRatio={CloudinaryResource.aspect_ratio}
          widths={[2000, 1200, 800]}
          draggable="false"
          sizes="(min-width: 1150px) 50vw, (min-width: 900px) 75vw, 100vw" // various layout breakpoints
          class="absolute align-bottom top-0 w-full h-full object-cover opacity-0 transition-opacity ease-in duration-1000"
          onload="this.style.opacity=1; this.parentNode.previousElementSibling.style.display = 'none';" // fade in image after loading, remove loading icon
          loading={`${index <= 5 ? "eager" : "lazy"}`}
          alt={`"Concert Photograph by Eric Dew${CloudinaryResource.context ? " of " + CloudinaryResource.context.alt : ""}`}
        />
      ) : (
        <video
          id={`video-${index}`}
          loop webkit-playsinline playsinline
          preload="none"
          onclick="this.paused ? this.play() : this.pause()"
          onmouseover="previewVideo(this)"
          onmouseout="resetVideo(this)"
          poster-src={CloudinaryResource.secure_url.replace(".mp4", ".jpg")}
          class="absolute top-0 h-full w-full object-cover align-bottom"
        >

          <source src={CloudinaryResource.secure_url} type="video/mp4" />
          Your browser does not support HTML video.

        </video>

          <div class="video-duration absolute top-0 flex w-full items-center justify-end bg-gradient-to-b from-black/50 to-transparent font-mono">
            <div class="text-xs">
              <span id={`current-time-video-${index}`} class="current-time hidden">0:00 / </span>
              <span>{new Date(CloudinaryResource.duration * 1000).toISOString().slice(15, 19)}</span>
            </div>
            <Icon name="circle-play-regular" class="fill-slate-100 h-6 m-2" />
          </div>
      )}
    </div>
  ))}

  <!-- placeholders required to properly size images in the last/incomplete row -->
  {Array.from({length: 10}, () => (
    <div class="m-0 h-0 grow-[100] basis-[240px]"></div>
  ))}

</div>

<div id="fullscreen-controls" class="fixed top-0 z-[1] hidden">
  <button type="button" onclick="prevImage()" class="fixed left-0 mt-[25vh] flex h-[50vh] w-[15vw] items-center opacity-0 hover:opacity-100 md:w-[25vw]">
    <div class="absolute left-0 ml-4 rounded-full bg-neutral-700 p-2 md:ml-8 md:p-4">
      <Icon name="chevron-left-solid" class="w-4 md:w-6 h-4 md:h-6 fill-slate-100" />
      <span class="sr-only">previous image</span>
    </div>
  </button>

  <button type="button" onclick="nextImage()" class="fixed right-0 mt-[25vh] flex h-[50vh] w-[15vw] items-center opacity-0 hover:opacity-100 md:w-[25vw]">
    <div class="absolute right-0 mr-4 rounded-full bg-neutral-700 p-2 md:mr-8 md:p-4">
      <Icon name="chevron-right-solid" class="w-4 md:w-6 h-4 md:h-6 fill-slate-100" />
      <span class="sr-only">next image</span>
    </div>
  </button>

  <button type="button" onclick="escapeFullscreen(true)" class="fixed mt-2 ml-2 rounded-full p-3 hover:bg-slate-100/10">
    <Icon name="xmark-solid" class="w-6 h-6 fill-slate-100" />
    <span class="sr-only">exit image</span>
  </button>
</div>

<style>
  @keyframes slideOutLeftImage {
    from {
      transform: translateX(0%);
      opacity: 1;
    }
    to {
      transform: translateX(-50%);
      opacity: 0;
    }
  }

  @keyframes slideOutRightImage {
    from {
      transform: translateX(0%);
      opacity: 1;
    }
    to {
      transform: translateX(50%);
      opacity: 0;
    }
  }

  @keyframes slideInLeftImage {
    from {
      transform: translateX(-50%);
      opacity: 0;
    }
    to {
      transform: translateX(0%);
      opacity: 1;
    }
  }

  @keyframes slideInRightImage {
    from {
      transform: translateX(50%);
      opacity: 0;
    }
    to {
      transform: translateX(0%);
      opacity: 1;
    }
  }

  .slideOutLeftImage {
    animation: slideOutLeftImage 150ms ease-in-out;
  }

  .slideOutRightImage {
    animation: slideOutRightImage 150ms ease-in-out;
  }

  .slideInLeftImage {
    animation: slideInLeftImage 100ms ease-in-out;
  }

  .slideInRightImage {
    animation: slideInRightImage 100ms ease-in-out;
  }

  @keyframes slideOutLeftVideo {
    from {
      left: 50%;
      opacity: 1;
    }
    to {
      left: 25%;
      opacity: 0;
    }
  }

  @keyframes slideOutRightVideo {
    from {
      left: 50%;
      opacity: 1;
    }
    to {
      left: 75%;
      opacity: 0;
    }
  }

  @keyframes slideInLeftVideo {
    from {
      left: 25%;
      opacity: 0;
    }
    to {
      left: 50%;
      opacity: 1;
    }
  }

  @keyframes slideInRightVideo {
    from {
      left: 75%;
      opacity: 0;
    }
    to {
      left: 50%;
      opacity: 1;
    }
  }

  .slideOutLeftVideo {
    animation: slideOutLeftVideo 150ms ease-in-out;
  }

  .slideOutRightVideo {
    animation: slideOutRightVideo 150ms ease-in-out;
  }

  .slideInLeftVideo {
    animation: slideInLeftVideo 100ms ease-in-out;
  }

  .slideInRightVideo {
    animation: slideInRightVideo 100ms ease-in-out;
  }

  @keyframes fadeInImage {
    from {
      scale: 0.75;
      opacity: 0;
    }
    to {
      scale: 1;
      opacity: 1;
    }
  }

  @keyframes fadeInVideo {
    from {
      scale: 0.75;
      opacity: 0;
    }
    to {
      scale: 1;
      opacity: 1;
    }
  }

  .fadeInImage {
    animation: fadeInImage 100ms ease-in-out;
  }

  .fadeInVideo {
    animation: fadeInVideo 100ms ease-in-out;
  }

  #fullscreen {
    position: fixed;
    z-index: 1;
    cursor: auto;
    width: 100vw;
    height: 100vh;
    top: 0;
    left: 0;
    background: black;
    margin: 0;
  }

  #fullscreen img {
    object-fit: contain;
  }

  #fullscreen video {
    height: 100vh;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: auto;
  }

  #fullscreen div[role="status"] {
    display: block;
  }

  #fullscreen .video-duration {
    padding-right: 1.5rem;
    padding-top: 1.5rem;
  }

  #fullscreen .current-time {
    display: inline-flex;
  }

  #fullscreen .video-duration svg {
    display: none;
  }
</style>

<script client:inline>
  // used in components to differentiate taps vs scrolling on mobile
  let isScrolling = false;

  let isAnimating = false;

  function setFullscreen(element, animation) {
    if (element.id == "fullscreen") {
      return;
    }

    element.scrollIntoView({ block: "center" });
    element.id = "fullscreen";

    const video = element.querySelector("video");

    if (video) {
      video.focus();
      if (video.paused) setTimeout(() => { video.play(); }, 1);
      video.muted = false;
    }

    document.body.classList.add("overflow-hidden");

    // delay to prevent accidental fullscreen controls trigger on inital touch opening media
    setTimeout(function () {
      document.getElementById("fullscreen-controls").classList.remove("hidden");
    }, 1);

    if (animation) {
      element.querySelector("img")?.classList.add(animation + "Image");
      element.querySelector("video")?.classList.add(animation + "Video");

      isAnimating = true;

      setTimeout(function () {
        element.querySelector("img")?.classList.remove(animation + "Image");
        element.querySelector("video")?.classList.remove(animation + "Video");

        isAnimating = false;
      }, 100);
    }
  }

  function getFullscreen() {
    return document.getElementById("fullscreen");
  }

  function escapeFullscreen(animation) {
    const fullscreen = getFullscreen();

    isAnimating = false;

    if (fullscreen) {
      fullscreen.removeAttribute("id");
      fullscreen.querySelector("video")?.pause();
      fullscreen.querySelector("video")?.blur();
      document.body.classList.remove("overflow-hidden");
      document.getElementById("fullscreen-controls").classList.add("hidden");
    }
  }

  function nextImage() {
    if (isAnimating) return;

    const fullscreen = getFullscreen();

    if (fullscreen) {
      fullscreen.querySelector("img")?.classList.add("slideOutLeftImage");
      fullscreen.querySelector("video")?.pause();
      fullscreen.querySelector("video")?.classList.add("slideOutLeftVideo");

      isAnimating = true;

      setTimeout(function () {
        fullscreen.querySelector("img")?.classList.remove("slideOutLeftImage");
        fullscreen.querySelector("video")?.classList.remove("slideOutLeftVideo");

        isAnimating = false;

        escapeFullscreen(false);
        setFullscreen(
          fullscreen.dataset.position == "last"
            ? document.querySelector("[data-position='first']")
            : fullscreen.nextSibling,
          "slideInRight"
        );
      }, 150);
    }
  }

  function prevImage() {
    if (isAnimating) return;

    const fullscreen = getFullscreen();

    if (fullscreen) {
      fullscreen.querySelector("img")?.classList.add("slideOutRightImage");
      fullscreen.querySelector("video")?.pause();
      fullscreen.querySelector("video")?.classList.add("slideOutRightVideo");

      isAnimating = true;

      setTimeout(function () {
        fullscreen.querySelector("img")?.classList.remove("slideOutRightImage");
        fullscreen.querySelector("video")?.classList.remove("slideOutRightVideo");

        isAnimating = false;

        escapeFullscreen(false);
        setFullscreen(
          fullscreen.dataset.position == "first"
            ? document.querySelector("[data-position='last']")
            : fullscreen.previousSibling,
          "slideInLeft"
        );
      }, 150);
    }
  }

  document.onkeydown = function (event) {
    const fullscreen = getFullscreen();

    if (!fullscreen || isAnimating) {
      return;
    }

    if (event.key == "Escape") {
      escapeFullscreen(true);
    } else if (event.key == "ArrowLeft" || event.key == "ArrowUp") {
      prevImage();
    } else if (event.key == "ArrowRight" || event.key == "ArrowDown") {
      nextImage();
    }
  };

  function previewVideo(video) {
    if (!getFullscreen()) {
      video.muted = true;
      video.play();
    }
  }

  function resetVideo(video) {
    if (!getFullscreen()) {
      video.muted = false;
      video.currentTime = 0;
      video.pause();
    }
  }

  const threshold = 50; // threshold value in pixels
  let startX;
  let endX;
  let startY;
  let endY;

  document.addEventListener("touchstart", (e) => {
    isScrolling = false;
    startX = e.changedTouches[0].screenX;
    startY = e.changedTouches[0].screenY;
  }, { passive: true });

  document.addEventListener("touchmove", (e) => {
    isScrolling = true;
  }, { passive: true });

  document.addEventListener("touchend", (e) => {
    endX = e.changedTouches[0].screenX;
    endY = e.changedTouches[0].screenY;

    const fullscreen = getFullscreen();

    if (!fullscreen || isAnimating) {
      return;
    }

    // prevent small movements
    if (Math.abs(startX - endX) < threshold && Math.abs(startY - endY) < threshold) {
      return;
    }

    // vertical scrolling
    if (Math.abs(startY - endY) > threshold) {
      escapeFullscreen();
      return;
    }

    if (endX < startX) nextImage();
    else if (endX > startX) prevImage();
  });
</script>

<!-- handle updating the current time of the video playing when fullscreen -->
<script client:inline>
  const videos = document.querySelectorAll("video");
  const intervals = {};

  videos.forEach(function (video) {
    const currentTimeSpan = document.getElementById(`current-time-${video.id}`);

    video.addEventListener("play", () => {
      intervals[video.id] = setInterval(() => {
        const minutes = Math.floor(video.currentTime / 60);
        const seconds = Math.floor(video.currentTime % 60);
        currentTimeSpan.innerHTML = `${minutes}:${seconds.toString().padStart(2, "0")} / `;
      }, 500);
    });

    video.addEventListener("pause", () => {
      clearInterval(intervals[video.id]);
    });
  });
</script>

<script src="../scripts/lazy-load-videos.js"></script>
